<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ChordPro Viewer — Full Tag + PDF</title>
<style>
  :root{--bg:#f6f8fb;--card:#fff;--muted:#6b7280;--accent:#1f6feb}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:18px;background:var(--bg);color:#111}
  .container{max-width:920px;margin:0 auto}
  header h1{margin:0;font-size:20px}
  header p{margin:6px 0 14px;color:var(--muted)}
  textarea{width:100%;min-height:180px;font-family:monospace;padding:10px;border-radius:6px;border:1px solid #ddd;box-sizing:border-box}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .btn{background:var(--accent);color:white;border:none;padding:8px 10px;border-radius:6px;cursor:pointer}
  .btn.secondary{background:white;color:var(--accent);border:1px solid rgba(31,111,235,0.14)}
  .meta{margin:12px 0}
  .song-title{font-size:1.5rem;font-weight:700;margin:0}
  .song-sub{color:var(--muted);margin:4px 0 8px}
  .meta-row{display:flex;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:0.95rem}
  .viewer{background:var(--card);padding:14px;border-radius:10px;box-shadow:0 2px 8px rgba(16,24,40,0.04)}
  pre { font-family:monospace; white-space:pre; margin:6px 0; padding:8px; border-radius:6px; background:#ffffff; border:1px solid #eee; line-height:1.45; font-size:15px; }
  .section-label{font-style:italic;color:var(--muted);margin:6px 0;font-size:0.95rem}
  .chorus{border-left:3px solid #e6f0ff;background:#fbfdff;padding:8px;border-radius:6px}
  .bridge{border-left:3px dashed #f7f3e6;background:#fffef9;padding:8px;border-radius:6px}
  .tab pre{background:#0b1220;color:#cfe8ff;overflow:auto}
  .comment{color:var(--muted);font-style:italic;margin:6px 0}
  .unknown-tag{color:#444;font-size:0.92rem;background:#f7f7f7;padding:6px;border-radius:6px;margin:6px 0}
  footer{color:var(--muted);font-size:13px;text-align:center;margin-top:18px}
  @media (max-width:560px){ .song-title{font-size:1.25rem} pre{font-size:14px} }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>ChordPro Viewer — Full Tag + PDF</h1>
    <p class="meta">Paste your ChordPro text below. Supports metadata tags, block directives, transpose, and export to PDF/Print.</p>
  </header>

  <div style="margin-bottom:12px">
    <textarea id="source" placeholder="{title: Song}\n{artist: Someone}\n[C]Hello [G]world"></textarea>
    <div class="controls" style="margin-top:8px">
      <button id="loadExample" class="btn secondary">Load Example</button>
      <button id="render" class="btn">Render</button>
      <button id="exportPdf" class="btn secondary">Export PDF / Print</button>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <button id="transposeDown" class="btn secondary">Transpose −</button>
        <span id="transposeVal" style="min-width:28px;text-align:center">0</span>
        <button id="transposeUp" class="btn secondary">Transpose +</button>
      </div>
    </div>
  </div>

  <div id="outputArea" class="viewer"></div>

  <footer>
    Host on GitHub Pages or embed via iframe into Google Sites.
  </footer>
</div>

<script>
// --- basic setup ---
const NOTES=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const flatToSharp={Db:'C#',Eb:'D#',Gb:'F#',Ab:'G#',Bb:'A#'};
let transposeSteps=0;

// --- helpers ---
function esc(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// transpose a token like "C#m7/G#"
function transposeChordToken(token,steps){
  const parts=token.split('/');
  const main=parts[0], bass=parts[1];
  const transSingle=(ch)=>{
    const m=ch.match(/^([A-G])([#b])?(.*)$/);
    if(!m) return ch;
    let [,root,acc,rest]=m;
    let full=root+(acc||'');
    if(flatToSharp[full]) full=flatToSharp[full];
    let idx=NOTES.indexOf(full);
    if(idx===-1) return ch;
    let ni=(idx+steps)%12; if(ni<0) ni+=12;
    return NOTES[ni]+(rest||'');
  };
  return bass ? transSingle(main)+'/'+transSingle(bass) : transSingle(main);
}

// apply transpose across text (only inside brackets)
function applyTransposeToText(text,steps){
  return text.replace(/\[([^\]]+)\]/g, (_, chordText) => {
    const tokens = chordText.split(/\s+/).map(t=>t.trim()).filter(Boolean);
    return '[' + tokens.map(t => transposeChordToken(t, steps)).join(' ') + ']';
  });
}

// render single line into two-row (chords above lyrics)
function renderLineTwoRow(line){
  let chordLine='', lyricLine='', inChord=false, chordBuf='';
  for(let i=0;i<line.length;i++){
    const ch=line[i];
    if(ch==='['){ inChord=true; chordBuf=''; }
    else if(ch===']'){ inChord=false;
      const pad = lyricLine.length - chordLine.length;
      if(pad>0) chordLine += ' '.repeat(pad);
      chordLine += chordBuf;
    } else if(inChord) chordBuf += ch;
    else lyricLine += ch;
  }
  if(chordLine.trim()) return `<pre>${esc(chordLine)}\n${esc(lyricLine)}</pre>`;
  if(lyricLine.trim()) return `<pre>${esc(lyricLine)}</pre>`;
  return '<div style="height:8px"></div>';
}

// --- main parser ---
function parseChordPro(text){
  const lines = text.replace(/\r/g,'').split('\n');
  const meta = {};
  const otherTags = {};
  const outputParts = [];
  let blockStack = [];
  let blockType = null;

  function openBlock(type){
    blockStack.push(type);
    blockType = type;
    if(type==='chorus') outputParts.push('<div class="chorus"><div class="section-label">Chorus</div>');
    else if(type==='bridge') outputParts.push('<div class="bridge"><div class="section-label">Bridge</div>');
    else if(type==='tab') outputParts.push('<div class="tab">');
    else if(type==='comment_box') outputParts.push('<div class="comment" style="border:1px solid #eee;padding:8px;background:#fff">');
  }
  function closeBlock(){
    if(blockStack.length===0) return;
    const top = blockStack.pop();
    if(top==='chorus' || top==='bridge' || top==='tab' || top==='comment_box') outputParts.push('</div>');
    blockType = blockStack[blockStack.length-1] || null;
  }

  for(let rawLine of lines){
    const line = rawLine.trimEnd();

    // match {tag: value} or {tag}
    const tagKV = line.match(/^\{([^:}]+):\s*(.*?)\}$/);
    const tagToken = line.match(/^\{([a-zA-Z0-9_\-]+)\}$/);

    if(tagKV){
      const tag = tagKV[1].toLowerCase();
      const val = tagKV[2];
      if(['title','subtitle','artist','album','composer','lyricist','capo','key','time','tempo','language','duration','arranger'].includes(tag)){
        meta[tag] = val;
      } else if(['comment','comment_italic','comment_box'].includes(tag)){
        if(tag==='comment_italic') outputParts.push(`<div class="comment" style="font-style:italic">${esc(val)}</div>`);
        else outputParts.push(`<div class="comment">${esc(val)}</div>`);
      } else {
        otherTags[tag] = val;
      }
      continue;
    } else if(tagToken){
      const token = tagToken[1].toLowerCase();
      if(['start_of_chorus','soc','start_chorus'].includes(token)){ openBlock('chorus'); continue; }
      if(['end_of_chorus','eoc','end_chorus'].includes(token)){ closeBlock(); continue; }
      if(['start_of_bridge','start_bridge'].includes(token)){ openBlock('bridge'); continue; }
      if(['end_of_bridge','end_bridge'].includes(token)){ closeBlock(); continue; }
      if(['start_of_tab','start_tab'].includes(token)){ openBlock('tab'); continue; }
      if(['end_of_tab','end_tab'].includes(token)){ closeBlock(); continue; }
      if(['start_of_comment','comment_box'].includes(token)){ openBlock('comment_box'); continue; }
      if(['end_of_comment','end_comment'].includes(token)){ closeBlock(); continue; }
      // structural labels like {verse}, {chorus}, {bridge}
      if(['verse','chorus','bridge','refrain','solo'].includes(token)){
        outputParts.push(`<div class="section-label">${esc(token.toUpperCase())}</div>`);
        continue;
      }
      // unknown single token — show for debugging
      outputParts.push(`<div class="unknown-tag">{${esc(token)}}</div>`);
      continue;
    }

    // blank line -> small gap
    if(line.trim()===''){ outputParts.push('<div style="height:10px"></div>'); continue; }

    // if inside tab block, display raw pre
    if(blockType==='tab'){ outputParts.push(`<pre>${esc(line)}</pre>`); continue; }

    // normal lyric/chord line
    outputParts.push(renderLineTwoRow(line));
  }

  // close any remaining blocks
  while(blockStack.length) closeBlock();

  // build metadata header
  let metaHtml = '<div class="meta">';
  if(meta.title) metaHtml += `<div class="song-title">${esc(meta.title)}</div>`;
  if(meta.subtitle) metaHtml += `<div class="song-sub">${esc(meta.subtitle)}</div>`;
  if(meta.artist || meta.album){
    metaHtml += '<div class="meta-row">';
    if(meta.artist) metaHtml += `<div class="song-artist">Artist: ${esc(meta.artist)}</div>`;
    if(meta.album) metaHtml += `<div class="song-artist">Album: ${esc(meta.album)}</div>`;
    metaHtml += '</div>';
  }
  const extras = [];
  if(meta.key) extras.push('Key: ' + esc(meta.key));
  if(meta.capo) extras.push('Capo: ' + esc(meta.capo));
  if(meta.time) extras.push('Time: ' + esc(meta.time));
  if(meta.tempo) extras.push('Tempo: ' + esc(meta.tempo));
  if(extras.length) metaHtml += `<div class="meta-row" style="margin-top:6px">${extras.join(' • ')}</div>`;

  if(Object.keys(otherTags).length){
    metaHtml += '<div style="margin-top:8px"><strong>Other tags:</strong> ';
    metaHtml += Object.keys(otherTags).map(k => `<span style="margin-right:10px">${esc(k)}: ${esc(otherTags[k])}</span>`).join('');
    metaHtml += '</div>';
  }

  metaHtml += '</div>';
  return metaHtml + outputParts.join('\n');
}

// --- render pipeline ---
function render(){
  const raw = document.getElementById('source').value || '';
  const transApplied = applyTransposeToText(raw, transposeSteps);
  const html = parseChordPro(transApplied);
  document.getElementById('outputArea').innerHTML = html;
  document.getElementById('transposeVal').textContent = transposeSteps;
}

// --- controls ---
document.getElementById('render').addEventListener('click', render);
document.getElementById('transposeUp').addEventListener('click', ()=>{ transposeSteps++; render(); });
document.getElementById('transposeDown').addEventListener('click', ()=>{ transposeSteps--; render(); });

document.getElementById('loadExample').addEventListener('click', ()=>{
  document.getElementById('source').value =
`{title: Amazing Grace}
{subtitle: A classic hymn}
{artist: Traditional}
{album: Hymns}
{composer: John Newton}
{key: C}
{capo: 0}
{time: 3/4}
{tempo: 60}

{comment: Verse 1}
[C]Amazing [G]grace, how [C]sweet the [F]sound
That [C]saved a [G]wretch like [C]me

{start_of_chorus}
{comment: Refrain}
[C]I [F]once was [C]lost, but [G]now am [C]found
{end_of_chorus}

{start_of_tab}
e|------------------|
B|------------------|
{end_of_tab}

{comment_box: This viewer shows tags and structural blocks.}
`;
  render();
});

// --- Export to PDF / Print ---
document.getElementById('exportPdf').addEventListener('click', ()=>{
  const content = document.getElementById('outputArea').innerHTML;
  const title = document.querySelector('.song-title')?.textContent || 'ChordPro Song';
  const printWindow = window.open('', '_blank');
  const css = `
    body{font-family: Arial, sans-serif; margin:30px; color:#111; background:#fff}
    .meta { margin-bottom:18px; }
    .song-title{ font-size:1.5rem; font-weight:700; margin-bottom:6px; }
    .song-sub{ color:#555; margin-bottom:8px; }
    .meta-row{ color:#555; font-size:1rem; margin-bottom:8px; }
    pre{ font-family:monospace; white-space:pre; margin:6px 0; font-size:14px; line-height:1.4 }
    .chorus, .bridge, .tab, .comment{ border:none; background:#f8f8f8; padding:8px; margin:6px 0; border-radius:4px }
    .section-label{ font-style:italic; color:#666; margin:4px 0; }
    @media print {
      body{ margin:12mm; }
      .no-print{ display:none; }
      pre{ font-size:12px; }
    }
  `;
  printWindow.document.write(`<!doctype html><html><head><meta charset="utf-8"><title>${esc(title)}</title><style>${css}</style></head><body>${content}</body></html>`);
  printWindow.document.close();
  printWindow.focus();
  // give it a short moment then call print to ensure fonts load
  setTimeout(()=>{ printWindow.print(); }, 250);
});

// auto-render initial empty state
render();
</script>
</body>
</html>
